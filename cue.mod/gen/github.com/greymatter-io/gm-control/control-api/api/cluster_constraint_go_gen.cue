// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/greymatter-io/gm-control/control-api/api

package api

#ConstraintKey: string

//  ClusterConstraint describes a filtering of the Instances in a Cluster
// based on their Metadata. Instances in the keyed cluster with a superset
// of the specified Metadata will be included. The Weight of the
// ClusterConstraint is used to inform selection of one ClusterConstraint
// over another.
//
//  Metadata, properties, responsedata are only used for the `light` constraint.
//  They have no effect on `dark` and `tap` itself is not implemented.
//  For `dark` traffic, the `weight` field will be interpreted as a percentage out of 100.
#ClusterConstraint: {
	constraint_key: #ConstraintKey @go(ConstraintKey)
	cluster_key:    #ClusterKey    @go(ClusterKey)
	metadata?:      #Metadata      @go(Metadata)
	properties:     #Metadata      @go(Properties)
	response_data?: #ResponseData  @go(ResponseData)
	weight:         uint32         @go(Weight)
}

//  AllConstraints defines three different ClusterConstraint slices
//
// The Light ClusterConstraint slice is used to determine the Instance to
// which the live request will be sent and from which the response will be
// sent to the caller. The Dark ClusterConstraint slice is used to determine
// an Instance to send a send-and-forget copy of the request to. The Tap
// ClusterConstraint slice is used to determine an Instance to send a copy of
// the request to, comparing the response to the Light response.
//
// The Dark and Tap ClusterConstraint slices may be empty. The Light
// ClusterConstraint slice must always contain at least one entry.
#AllConstraints: {
	light: #ClusterConstraints @go(Light)
	dark?: #ClusterConstraints @go(Dark)
	tap?:  #ClusterConstraints @go(Tap)
}

#ClusterConstraints: [...#ClusterConstraint]
