// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/greymatter-io/gm-control/control-api/api

package api

// HealthCheck configures the parameters to do health checking against instances
// in a cluster.
#HealthCheck: {
	// TimeoutMsec is the time to wait for a health check response. If the
	// timeout is reached without a response, the health check attempt will
	// be considered a failure. This is a required field and must be greater
	// than 0.
	timeout_msec: int @go(TimeoutMsec)

	// IntervalMsec is the interval between health checks. Note that the
	// first round of health checks will occur during startup before any
	// traffic is routed to a cluster. This means that the
	// `NoTrafficIntervalMsec` value will be used as the first interval of
	// health checks.
	interval_msec: int @go(IntervalMsec)

	// IntervalJitterMsec is an optional jitter amount that is added to each
	// interval value calculated by the proxy. If not specified, defaults
	// to 0.
	interval_jitter_msec?: null | int @go(IntervalJitterMsec,*int)

	// UnhealthyThreshold is the number of unhealthy health checks required
	// before a host is marked unhealthy. Note that for *http* health
	// checking if a host responds with 503 this threshold is ignored and
	// the host is considered unhealthy immediately.
	unhealthy_threshold: int @go(UnhealthyThreshold)

	// HealthyThreshold is the number of healthy health checks required
	// before a host is marked healthy. Note that during startup, only a
	// single successful health check is required to mark a host healthy.
	healthy_threshold: int @go(HealthyThreshold)

	// ReuseConnection determines whether to reuse a health check connection
	// between health checks. Default is true.
	reuse_connection?: null | bool @go(ReuseConnection,*bool)

	// NoTrafficIntervalMsec is a special health check interval that is
	// used when a cluster has never had traffic routed to it. This lower
	// interval allows cluster information to be kept up to date, without
	// sending a potentially large amount of active health checking traffic
	// for no reason. Once a cluster has been used for traffic routing,
	// The proxy will shift back to using the standard health check interval
	// that is defined. Note that this interval takes precedence over any
	// other. Defaults to 60s.
	no_traffic_interval_msec?: null | int @go(NoTrafficIntervalMsec,*int)

	// UnhealthyIntervalMsec is a health check interval that is used for
	// hosts that are marked as unhealthy. As soon as the host is marked as
	// healthy, the proxy will shift back to using the standard health check
	// interval that is defined. This defaults to the same value as
	// IntervalMsec if not specified.
	unhealthy_interval_msec?: null | int @go(UnhealthyIntervalMsec,*int)

	// UnhealthyEdgeIntervalMsec is a special health check interval that
	// is used for the first health check right after a host is marked as
	// unhealthy. For subsequent health checks the proxy will shift back to
	// using either "unhealthy interval" if present or the standard
	// health check interval that is defined. Defaults to the same value as
	// UnhealthIntervalMsec if not specified.
	unhealthy_edge_interval_msec?: null | int @go(UnhealthyEdgeIntervalMsec,*int)

	// HealthyEdgeIntervalMsec is a special health check interval that is
	// used for the first health check right after a host is marked as
	// healthy. For subsequent health checks the proxy will shift back to
	// using the standard health check interval that is defined. Defaults
	// to the same value as IntervalMsec if not specified
	healthy_edge_interval_msec?: null | int @go(HealthyEdgeIntervalMsec,*int)

	// HealthChecker defines the type of health checking to use.
	health_checker: #HealthChecker @go(HealthChecker)
}

// HealthChecks is a slice of HealthCheck objects. Currently, the proxy only
// supports a single health check per cluster
#HealthChecks: [...#HealthCheck]

// HealthChecksByType implements sort.Interface to allow sorting by
// health check type
#HealthChecksByType: #HealthChecks

// HealthChecker is a union type where only a single field can be defined.
#HealthChecker: {
	// HTTPHealthCheck defines the parameters for http health checking.
	http_health_check?: null | #HTTPHealthCheck @go(HTTPHealthCheck,*HTTPHealthCheck)

	// TCPHealthCheck defines the parameters for tcp health checking.
	tcp_health_check?: null | #TCPHealthCheck @go(TCPHealthCheck,*TCPHealthCheck)
}

// HTTPHealthCheck configures the http health check endpoint for a cluster.
#HTTPHealthCheck: {
	// Host defines the value of the host header in the HTTP health check
	// request. If left empty (default value), the name of the cluster being
	// health checked will be used.
	host: string @go(Host)

	// Path specifies the HTTP path that will be requested during health
	// checking.
	path: string @go(Path)

	// ServiceName is an optional service name parameter which is used to
	// validate the identity of the health checked cluster. This is done by
	// comparing the `X-Envoy-Upstream-Healthchecked-Cluster` header to
	// this value.
	service_name: string @go(ServiceName)

	// RequestHeadersToAdd specifies a list of HTTP headers that should be
	// added to each request that is sent to the health checked cluster.
	request_headers_to_add?: #Metadata @go(RequestHeadersToAdd)
}

// TCPHealthCheck configures the tcp health checker for each instance in a
// cluster.
#TCPHealthCheck: {
	// Send is a base64 encoded string representing an array of bytes to be
	// sent in health check requests. Leaving this field empty implies a
	// connect-only health check.
	send: string @go(Send)

	// Receive is an array of base64 encoded strings, each representing
	// array of bytes that is expected in health check responses. When
	// checking the response, "fuzzy" matching is performed such that each
	// binary block must be found, and in the order specified, but not
	// necessarily contiguously.
	receive?: [...string] @go(Receive,[]string)
}
